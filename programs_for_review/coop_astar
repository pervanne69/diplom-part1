import heapq
from typing import List, Tuple, Dict, Set, Optional

MOVES = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 0)]

def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int:
    """
    Наименование: heuristic
    Назначение: эвристическая функция (Манхэттен) для A*-поиска.
    Входные параметры:
        a (Tuple[int,int]) - координаты первой точки (x,y).
        b (Tuple[int,int]) - координаты второй точки (x,y).
    Возвращаемое значение:
        int - значение эвристики (Манхэттенское расстояние).
    """
    return abs(a[0] - b[0]) + abs(a[1] - b[1])


def in_bounds(pos: Tuple[int, int], width: int, height: int) -> bool:
    """
    Наименование: in_bounds
    Назначение: проверка, находится ли позиция внутри границ сетки.
    Входные параметры:
        pos (Tuple[int,int]) - координата (x,y).
        width (int) - ширина сетки (количество столбцов).
        height (int) - высота сетки (количество строк).
    Возвращаемое значение:
        bool - True, если позиция внутри границ, иначе False.
    """
    x, y = pos
    return 0 <= x < width and 0 <= y < height


def is_free(grid: List[List[int]], pos: Tuple[int, int]) -> bool:
    """
    Наименование: is_free
    Назначение: проверяет, является ли клетка проходимой (не препятствие).
    Входные параметры:
        grid (List[List[int]]) - карта/сетка, 0 = проходимая, 1 = препятствие.
        pos (Tuple[int,int]) - координата (x,y).
    Возвращаемое значение:
        bool - True, если клетка свободна (0), иначе False.
    """
    x, y = pos
    return grid[y][x] == 0


def reconstruct(came_from: Dict[Tuple[int, int, int], Tuple[int, int, int]],
                current: Tuple[int, int, int]) -> List[Tuple[int, int]]:
    """
    Наименование: reconstruct
    Назначение: восстановление пути из словаря came_from (используется A* в пространстве-времени).
    Входные параметры:
        came_from (dict) - отображение: узел -> предшествующий узел, узел = (x,y,t).
        current (tuple) - конечный узел (x,y,t).
    Возвращаемое значение:
        List[Tuple[int,int]] - список позиций (x,y) по временам от старта до цели.
    """
    path = [(current[0], current[1])]
    while current in came_from:
        current = came_from[current]
        path.append((current[0], current[1]))
    path.reverse()
    return path


def a_star_time_expanded(grid: List[List[int]],
                         start: List[int],
                         goal: List[int],
                         reserved: Dict[int, Set[Tuple[int, int]]],
                         max_t: int = 500) -> Optional[List[Tuple[int, int]]]:
    """
    Наименование: a_star_time_expanded
    Назначение: выполняет A*-поиск в пространстве (x,y,t) с учётом временных резервов клеток.
    Входные параметры:
        grid (List[List[int]]) - карта сетки (0 = свободно, 1 = препятствие).
        start (List[int]) - стартовая позиция [x,y].
        goal (List[int]) - целевая позиция [x,y].
        reserved (Dict[int, Set[Tuple[int,int]]]) - словарь резервов: время -> набор занятых позиций.
        max_t (int) - максимальное число временных шагов (ограничение поиска).
    Возвращаемое значение:
        List[Tuple[int,int]] или None - путь как список (x,y) по временам от t=0 до t=N,
                                          либо None, если путь не найден.
    Примечание:
        - Функция использует простую обработку вершинных резервов (vertex reservations).
        - Edge-reservation (запрет на обмен позициями) не реализован в полной мере в этой версии.
    """
    width = len(grid[0])
    height = len(grid)
    start_node = (start[0], start[1], 0)
    openpq: List[Tuple[int, int, Tuple[int, int, int]]] = []
    heapq.heappush(openpq, (heuristic((start[0], start[1]), (goal[0], goal[1])), 0, start_node))
    came_from: Dict[Tuple[int, int, int], Tuple[int, int, int]] = {}
    gscore: Dict[Tuple[int, int, int], int] = {start_node: 0}

    while openpq:
        f, g, node = heapq.heappop(openpq)
        x, y, t = node
        if (x, y) == (goal[0], goal[1]):
            return reconstruct(came_from, node)
        if t >= max_t:
            continue
        for dx, dy in MOVES:
            nx, ny = x + dx, y + dy
            nt = t + 1
            if not in_bounds((nx, ny), width, height):
                continue
            if not is_free(grid, (nx, ny)):
                continue
            if nt in reserved and (nx, ny) in reserved[nt]:
                continue
            neigh = (nx, ny, nt)
            tentative_g = gscore[node] + 1
            if tentative_g < gscore.get(neigh, 10**9):
                gscore[neigh] = tentative_g
                came_from[neigh] = node
                fscore = tentative_g + heuristic((nx, ny), (goal[0], goal[1]))
                heapq.heappush(openpq, (fscore, tentative_g, neigh))
    return None


def cooperative_a_star(grid: List[List[int]],
                       agents: List[Dict]) -> Dict[int, List[Tuple[int, int]]]:
    """
    Наименование: cooperative_a_star
    Назначение: последовательное (декапсулированное) планирование путей для набора агентов
               с использованием A* в пространстве-времени (time-expanded A*).
               Для каждого агента планируется маршрут по очереди; занятые клетки резервируются
               по времени, чтобы последующие агенты учитывали уже запланированные траектории.
    Входные параметры:
        grid (List[List[int]]) - карта/сетка, 0 = свободная клетка, 1 = препятствие.
        agents (List[Dict]) - список описаний агентов:
            каждый элемент: {"id": int, "start": [x,y], "goal": [x,y]}
            Порядок в списке определяет приоритет планирования (первый агент планирует первым).
    Возвращаемое значение:
        Dict[int, List[Tuple[int,int]]] - словарь: agent_id -> путь (список (x,y) по временам).
                                           Если для агента путь не найден — в качестве пути
                                           возвращается список с единственной позицией старта.
    Примечание:
        - Функция делает простую последовательную резервацию по вершинам (vertex reservations).
        - Для корректной обработки swap-collisions (edge collisions) и динамического перепланирования
          потребуются доработки (edge-reservations, повторная попытка с изменением порядка планирования и т.д.).
    """
    reserved: Dict[int, Set[Tuple[int, int]]] = {}
    plans: Dict[int, List[Tuple[int, int]]] = {}
    max_path_len = 0

    for ag in agents:
        agent_id = ag["id"]
        start = ag["start"]
        goal = ag["goal"]
        path = a_star_time_expanded(grid, start, goal, reserved, max_t=1000)
        if path is None:
            path = [(start[0], start[1])]
        for t, pos in enumerate(path):
            reserved.setdefault(t, set()).add(tuple(pos))
        plans[agent_id] = path
        if len(path) > max_path_len:
            max_path_len = len(path)

    for aid, p in plans.items():
        if len(p) < max_path_len:
            goalpos = p[-1]
            p_extended = p + [goalpos] * (max_path_len - len(p))
            plans[aid] = p_extended

    return plans